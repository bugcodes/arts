## Algorithm

> [3题：在一个字符串s中，找出不包含重复字符的子串的最大长度](<https://leetcode.com/problems/longest-substring-without-repeating-characters/>)

**解题思路1-暴力求解**

找出该字符串所有的子串，然后检查每个子串是否包含重复字符，在所有不含重复字符的子串中找出最大值。

1. 用两层嵌套循环找出所有的子串。
2. 对每一个子串，判断是否包含重复字符，这里用到了Set集合来处理

```
public int lengthOfLongestSubstring(String s){
    int n = s.length();
    int max = 0;
    for(int i = 0;i < n;i++){
        for(int j = i+1;j <= n;j++){
            if(allUnique(s,i,j)){
                max = Math.max(ans, j - i);
            }
        }
    }
    return max;
}

/**
* 判断子串不包含重复字符
*/
public boolean allUnique(String s, int start, int end){
    Set<Character> set = new HashSet<>();
    for(int i = start;i < end; i++){
        Character ch = s.charAt(i);
        if(set.contains(ch)){
            return false;
        }else{
            set.add(ch);
        }
    }
    return true;
}
```

**Note:**时间复杂度**O(n3)**,空间复杂度**O(min(n,m))**，m是set集合的长度

------

**解题思路2-滑动窗口**

在思路1中，我们总会重复检查某个子串是否包含重复字符，其实这都是不必要的检查。如果我们对一个子串Sij，从索引i到j-1已经做了检查而且不存在重复字符，那么我们只需要在判断s[j]这个字符是否已经存在于子串Sij中，如果不存在，那说明Sij是一个不含重复字符的子串。这样可以把时间复杂度从O(n3)降低到O(n2)。

我们还可以继续优化，使用HashSet当做一个滑动窗口，HashSet检查一个字符串是否存在，只需要O(1)的时间复杂度。

**滑动窗口是数组、字符串问题中常用的抽象概念**

滑动窗口是将两个边界滑动到某个方向的窗口。例如把[i,j)向右滑动1个单元，窗口就变成了[i+1,j+1)。

回到我们的题目，我们用一个HashSet存储当前窗口[i,j)中的字符集合(初始窗口i=j)，然后我们滑动j边界到更远，在滑动到S[j]表示的字符在HashSet中存在为止，此时j-i就等于当前不包含重复字符子串的长度。

按照上述的方法，滑动左边界i，一直到最后，就能得到答案。

```
public int lengthOfLongestSubstring(String s){
    int n = s.length();
    Set<Character> set = new HashSet<>();
    int max = 0, i=0,j=0;
    while(i<n&&j<n){
        if(!set.contains(s.charAt(j))){
            set.add(s.charAt(j++));
            max = Math.max(max,j-i);
        }else{
            set.remove(s.charAt(i++));
        }
    }
    return max;
}
```



> [191题：求整数二进制中1的个数](<https://leetcode.com/problems/number-of-1-bits/>)

**解题思路1**

解决方法很直接，一个整数的二进制表示是32位，检查每一位，统计1的个数。从整数的最低有效位开始，向高位逐个检查是否为1。使用一个掩码m=1，任何数字和该掩码之间的位与(AND)操作都能够判断最低有效位是不是1。

```
00000000000000000000000000000001 掩码
00000010010000100000000011000000 某个整数
AND
----------------------------------------------------
00000000000000000000000000000000
结果为0说明最后一位不是1
```

```
00000000000000000000000000000010 掩码左移一位
00000010010000100000000011000000 某个整数
AND
----------------------------------------------------
00000000000000000000000000000000
结果为0说明倒数第二位不是1
```

```
00000000000000000000000001000000 掩码左移6位
00000010010000100000000011000000 某个整数
AND
----------------------------------------------------
00000000000000000000000001000000
结果不为0说明倒数第七位是1
```

**代码**

```
public int hammingWeight(int n){
    int bits = 0;
    int mask = 1;
    for(int i=0;i<32;i++){
        if((n&mask)!=0){
            bits++;
        }
        mask << 1;
    }
    return bits;
}
```

```
public int lengthOfLongestSubstring(String s){
    int n = s.length();
    Set<Character> set = new HashSet<>();
    int ans = 0,i = 0,j=0;
    while(i<n&&j<n){
        if(!set.contains(s.charAt(j))){
            set.add(s.charAt(j++));
            ans = Math.max(ans,j-i);
        }else{
            set.remove(s.charAt(i++));
        }
    }
    return ans;
}
```

## Review

> [你为什么要学习go语言](<https://medium.com/@kevalpatel2106/why-should-you-learn-go-f607681fad65>)

Go将会成为未来的服务器语言。

这篇文章并不是要教你如何用Go语言来写“hello world”，而是讲述了现阶段的计算机软硬件情况以及为什么需要一种像Go这样的新语言。大概从**硬件的限制**、**Go拥有goroutines**(与Java语言相比，在64位的环境中，JVM会为每个线程分配1M的栈，默认的栈空间大小能够支持1000个线程，上百万上线程需要TB级别的RAM，而Go的栈是动态分配大小的，随着存储数据的数量而增长或抽缩，每创建一个Goroutine需要有大约4KB的栈，1GB的RAM就能支持250万个Goroutine)、**Go直接运行在底层硬件上**（相对于C/C++）它少了一层VM、用Go编写的代码易于维护，最后把Google也搬出来了，说是Go是由Google设计并支持的。

## Tip

Oracle+Mybaits比较问题：**不等于(!=)**

工作中遇到一个问题，类似于求用户类型不等于VIP(常量值1)的用户信息。

**需求：**数据库中该字段user_type的类型为varchar2，该字段值包含Null、1、0，要找出不为1的信息

SQL语句对应如下

```
select user_name from user where user_type != '1'
```

数据库选择MySQL，上述语句对应Mysql Example如下,能够查询中用户类型不等于VIP的用户信息。

```
UserCriteria sql = new UserCriteria();
sql.or().andUserTypeNotEqualTo(UserType.VIP);
return mapper.selectByExample(sql);
```

**遇到问题：**但是选择Oracle数据库，上述业务逻辑就会有问题，如果某条记录中user_type的字段值为null的话，查询不到该条记录。想要过滤中为null的信息，需要用到**is null**

**解决方案：** 找出不为1的信息，那么需要找出值为Null和值为0的并集。

```
UserCriteria sql = new UserCriteria();
sql.createCriteria().andUserTypeIsNull();    sql.or(sql.createCriteria().andUserTypeEqualTo(UserType.SVIP));
return mapper.selectByExample(sql);
```

## Share

Lucene学习笔记-**TF-IDF检索模型**

tf-idf是**term frequency-inverse document frequency**的缩写，tf表示词项频率，df表示文档频率。

**tf-idf**成为**词频-逆文档频率**，用于计算词项对于一个文档集或者语料库中一份文件的重要程度，也就是词项的权重。词项的重要性随着它再文档中出现的次数成正比增加，但同时会随着它在文档中集中出现的频率成反比。如果一个词在一篇文档中出现的频率非常高，说明其重要性比较高，但是如果这个词项在文档集中的其他文档中出现的频率也很高，那说明这个词项有可能是比较常见的。

#### TF计算方法

1. 文档有长短之分，一篇长文章中某个词语出现3次，很难断定该文章与该词语有关，但是在一篇140字的短文章中出现3次，那该词语与该文章内容就会有很大的关系，以下计算方法可以削弱文档长度的影响

   ```
   词频 tf= （单词在文档中出现的次数）/（文档的总次数）
   ```


2. Lucene采用的词频标准化方法

   ```
   词频tf = \sqrt 单词在文档中出现的次数
   ```


#### DF计算方法 

df通常比较大，把它映射到一个较小的范围，用**idf**来表示，分母中+1是为了防止为0的情况

```
逆文档频率idf = log(文档集总的文档数/(包含某个单词的文档数+1))
```

词项的权重**tf-idf**的计算公式如下

```
tf-idf = 词频tf * 逆文档频率idf
```

通过tf-idf可以把文档表示成n维的词项权重向量

```
document vector = (W_1,W_2...Wn)
```

