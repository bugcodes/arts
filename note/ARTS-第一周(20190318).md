## Algorithm

> [11题](https://leetcode.com/problems/container-with-most-water/)

给定n个非负整数a1，a2，...，an，每个整数表示一个坐标(i，ai)。绘制n条垂直线，使得线i的两个端点位于（i，0）和（i，ai）。找到两条线，它们与x轴一起形成一个容器，使得该容器含有最多的水。

注意：容器不会倾斜，n至少为2

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/07/17/question_11.jpg)

上图由数组[1,8,6,2,5,4,8,3,7]表示。在这种情况下，容器可容纳的最大水面积（蓝色部分）为49。

**示例**

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49
```

**解题思路**

1. 求容器的最大可容纳面积，也就是求长方形的最大面积，长方形的长度是两点的索引间距，高度是某个数an

2. 根据木桶原理，取短边，两数之间取较小的数，较小的数就是长方形的高度
3. 取数组中两点的索引间距，这个间距就是长方形的宽度
4. 找到两个数，使得长度 (Math.min(ax,ay)) * (y-x) 最大

**方法1：暴力求解**

```
public int maxArea(int[] height){
    int maxArea = 0;
    for(int i = 0; i<height.length;i++){
        for(int j=i+1;j<height.length;j++){
            //宽度
            int w = j-i;
            //高度
            int h = Math.min(height[i],height[j]);
            //求最大面积
            maxArea = Math.max(maxArea,w*h);
        }
    }
    return maxArea;
}
```

时间复杂度O(n*n) , 时间复杂度O(1),请忽略局部变量w和h,这里只是为了便于理解

**方法2：两游标求解**

```
public int maxArea(int[] height){
    int maxArea = 0,left = 0,right=height.length-1;
    while(left < right){
        maxArea = Math.max(maxArea,Math.min(height[left],height[right])*(right-left));
        if(height[left]<height[right]){
            left++;
        }else{
            right++;
        }
    }
    return maxArea;
}
```

时间复杂度O(n) , 时间复杂度O(1)

## Review

> [75岁老大爷的魔幻之旅](https://humanparts.medium.com/can-a-75-year-old-do-psychedelics-7c2727ac542)

话说一个75岁的老大爷和一个58岁的大妈经常外出游玩，他俩喜欢冒险。通过冒险他们获得了很多非凡的体验，然后就想着成为神经大师。

老大爷年轻的时候，大概40年前吧，老大爷品尝过各种致幻剂，他说现在想起来那是的情景都不曾感到后悔，还说自己很热爱生活。他俩想通过致幻剂来成就神经大师之路，然后老大爷想了个好办法，就是吃毒蘑菇。

先让大妈吃，大爷守着大妈，观察大妈的反映，然后大爷再吃，大妈守着，好像两人都体会了非凡的感觉。

最后老大爷说这是他们晚年对于魔幻剂的探索。

**STOP** 请原谅我满嘴跑火车，原文我大概能看懂三分之一吧。

**比较有意思的是下面的评论**，一哥们留言说，他老爹都77岁了，在死之前，想在精神上获得更多对世界的了解，然后这哥们推荐他老爹吃毒蘑菇，吃毒蘑菇，吃毒蘑菇，还征求了下作者的意见。

真正花心思去读英文文章，找到了初中的感觉，句子的构成简直就是用单词尬组的。学习英语，一路磕磕绊绊，希望有所长进吧。

##  Tip

在Spring项目中，在业务逻辑层的方法类中通常会加@Service或者@Component注解，当工程启动时，Spring会自动加载这些Bean到Spring容器中，业务逻辑中的许多方法类会有相同的处理逻辑，这时候可以考虑使用抽象工厂方法来简化代码。

先定义一个公共的抽象类

```
public abstract class AbstractProcessor{

    /**
     * 通用处理逻辑
     */
    public abstract void apply();
}
```

具体业务实现类

```
@Service
public class ConcreteOneProcessor extends AbstractProcessor{
    
    public void apply(){
        //one的具体实现
    }
    
    public void doSome(){
        //one特定的一些实现
    }
}

@Service
public class ConcreteTwoProcessor extends AbstractProcessor{
    
    public void apply(){
        //two的具体实现
    }
    
    public void doAnother(){
        //one特定的一些实现
    }
}
```

工厂类

```
@Service
public class ProcessorFactory{

    private final Map<String,AbstractProcessor> m = new HashMap<>();
    
    @Autowired
    public ProcessorFactory(Map<String,AbstractProcessor> map){
        m.clear();
        map.forEach((k, v) -> m.put(v.apply(), v));
    }
    
    /**
     * 工厂方法
     */
    public AbstractProcessor getInstance(String service){
        AbstractProcessor processor = m.get(service);
        return processor;
    }
}
```

使用

```
@Autowired
ProcessorFactory factory;

//获取具体的方法类
AbstractProcessor concreteOneProcessor = factory.getInstance("concreteOneProcessor");
```

## Share

在项目开发过程中，多人协同工作，各模块负责人大都有沙箱环境的数据库的读写权限，调试过程中常常会遇到锁表的情况，有时为了节省时间就不去找DBA，可以试着通过以下方式，找到相关的锁表记录，kill掉相关进程。当然，提前是需要有数据库的root用户权限。

查看正在锁的事务

SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;

查看等待锁的事务

SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;

查询 正在执行的事务：

```
SELECT * FROM information_schema.INNODB_TRX;
```

查看事务等待状况：

```
SELECT
     r.trx_id waiting_trx_id,
     r.trx_mysql_thread_id waiting_thread,
     r.trx_query waiting_query,
     b.trx_id blocking_trx_id,
     b.trx_mysql_thread_id blocking_thread,
     b.trx_query blocking_query
FROM
     information_schema.innodb_lock_waits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```

查看更具体的事务等待状况：

```
SELECT
     b.trx_state,
     e.state,
     e.time,
     d.state AS block_state,
     d.time AS block_time,
     a.requesting_trx_id,
     a.requested_lock_id,
     b.trx_query,
     b.trx_mysql_thread_id,
     a.blocking_trx_id,
     a.blocking_lock_id,
     c.trx_query AS block_trx_query,
     c.trx_mysql_thread_id AS block_trx_mysql_tread_id
FROM
     information_schema.INNODB_LOCK_WAITS a
LEFT JOIN information_schema.INNODB_TRX b ON a.requesting_trx_id = b.trx_id
LEFT JOIN information_schema.INNODB_TRX c ON a.blocking_trx_id = c.trx_id
LEFT JOIN information_schema.PROCESSLIST d ON c.trx_mysql_thread_id = d.id
LEFT JOIN information_schema.PROCESSLIST e ON b.trx_mysql_thread_id = e.id
ORDER BY
     a.requesting_trx_id;
```

查看未关闭的事务： –MySQL 5.6

```
SELECT
     a.trx_id,
     a.trx_state,
     a.trx_started,
     a.trx_query,
     b.ID,
     b.USER,
     b.DB,
     b.COMMAND,
     b.TIME,
     b.STATE,
     b.INFO,
     c.PROCESSLIST_USER,
     c.PROCESSLIST_HOST,
     c.PROCESSLIST_DB,
     d.SQL_TEXT
FROM
     information_schema.INNODB_TRX a
LEFT JOIN information_schema.PROCESSLIST b ON a.trx_mysql_thread_id = b.id
AND b.COMMAND = 'Sleep'
LEFT JOIN PERFORMANCE_SCHEMA.threads c ON b.id = c.PROCESSLIST_ID
LEFT JOIN PERFORMANCE_SCHEMA.events_statements_current d ON d.THREAD_ID = c.THREAD_ID;
```

–MySQL 5.5

```
SELECT
     a.trx_id,
     a.trx_state,
     a.trx_started,
     a.trx_query,
     b.ID,
     b. USER,
     b. HOST,
     b.DB,
     b.COMMAND,
     b.TIME,
     b.STATE,
     b.INFO
FROM
     information_schema.INNODB_TRX a
LEFT JOIN information_schema.PROCESSLIST b ON a.trx_mysql_thread_id = b.id
WHERE
     b.COMMAND = 'Sleep';
```

查看某段时间以来未关闭事务：

```
SELECT
        trx_id,
        trx_started,
        trx_mysql_thread_id
FROM
        INFORMATION_SCHEMA.INNODB_TRX
WHERE
        trx_started < date_sub(now(), INTERVAL 1 MINUTE)
AND trx_operation_state IS NULL
AND trx_query IS NULL;
```